<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
	<meta name="viewport" content="user-scalable=no, initial-scale=1">

  <style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
  </style>
</head>
<body>
  test

  <div id="container"></div>


  <script src="js/three.min.js"></script>
  <script src="js/DeviceOrientationControls.js"></script>

  <script>
			(function() {
				  "use strict";

				  window.addEventListener('load', function() {

						var container, camera, scene, renderer, controls, geometry, mesh, dirLight, hemiLight;

						var animate = function(){

							window.requestAnimationFrame( animate );

							controls.update();
							renderer.render(scene, camera);

						};

						container = document.getElementById( 'container' );

						// camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
                        // camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );

            var rapportHL, cameraWidth;
            cameraWidth = 175;
            rapportHL = window.innerHeight/window.innerWidth;
            camera = new THREE.OrthographicCamera( -cameraWidth, cameraWidth, cameraWidth*rapportHL, -cameraWidth*rapportHL     , -500, 1500 );

						controls = new THREE.DeviceOrientationControls( camera );

						scene = new THREE.Scene();

						var geometry = new THREE.SphereGeometry( 500, 128, 64 );
						geometry.scale( - 1, 1, 1 );
						var material = new THREE.MeshBasicMaterial( {
							// map: new THREE.TextureLoader().load( 'Test_01.jpg' )
                  map: new THREE.TextureLoader().load( 'pan-test-jh_test.png' )
						} );
						var mesh = new THREE.Mesh( geometry, material );
						scene.add( mesh );

            var loader = new THREE.JSONLoader();
            loader.load( 'ToyPlaneJoined.json', function( geometry, materials ) {
                // var material = new THREE.MeshBasicMaterial( { color: 0xff00ff, side: THREE.BackSide, wireframe: true } );
                // var material = materials[ 0 ];
                var mesh = new THREE.Mesh( geometry, materials );
                mesh.position.z = -50;
                mesh.scale.set(10,10,10);

                mesh.castShadow = true;
                mesh.receiveShadow = true;

                scene.add( mesh );
             } );

						var geometry = new THREE.BoxGeometry( 100, 100, 100, 4, 4, 4 );
						var material = new THREE.MeshBasicMaterial( { color: 0xff00ff, side: THREE.BackSide, wireframe: true } );
						var mesh = new THREE.Mesh( geometry, material );
						scene.add( mesh );

            // LIGHTS

    				var ambientLight = new THREE.AmbientLight( 0xcccccc );
    				scene.add( ambientLight );

    				//

            hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
    				hemiLight.color.setHSL( 0.6, 1, 0.6 );
    				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
    				hemiLight.position.set( 0, 500, 0 );
    				scene.add( hemiLight );

            //

            dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
    				dirLight.color.setHSL( 0.1, 1, 0.95 );
    				dirLight.position.set( -1, 1.75, 1 );
    				dirLight.position.multiplyScalar( 50 );
    				scene.add( dirLight );

            dirLight.castShadow = true;

    				dirLight.shadow.mapSize.width = 2048;
    				dirLight.shadow.mapSize.height = 2048;

    				var d = 50;

    				dirLight.shadow.camera.left = -d;
    				dirLight.shadow.camera.right = d;
    				dirLight.shadow.camera.top = d;
    				dirLight.shadow.camera.bottom = -d;

    				dirLight.shadow.camera.far = 3500;
    				dirLight.shadow.bias = -0.0001;


            // RENDERER

						renderer = new THREE.WebGLRenderer( { antialias: true } );
						renderer.setPixelRatio( window.devicePixelRatio );
						renderer.setSize(window.innerWidth, window.innerHeight);
						renderer.domElement.style.position = 'absolute';
						renderer.domElement.style.top = 0;
						container.appendChild(renderer.domElement);

            renderer.shadowMap.enabled = true;
    				renderer.shadowMap.renderReverseSided = false;

						window.addEventListener('resize', function() {

						camera.aspect = window.innerWidth / window.innerHeight;
						camera.updateProjectionMatrix();
						renderer.setSize( window.innerWidth, window.innerHeight );

						}, false);

						animate();

				  }, false);

			})();
      </script>
</body>
</html>
